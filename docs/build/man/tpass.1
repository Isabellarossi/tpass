.\" Man page generated from reStructuredText.
.
.TH "TPASS" "1" "Aug 23, 2019" "0.1.7" "tpass"
.SH NAME
tpass \- tpass Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH INSTALL
.SS Contents
.INDENT 0.0
.IP \(bu 2
\fI\%Install\fP
.UNINDENT
.SH 1\ \ \ MANUAL
.SS The tiny table of contents
.INDENT 0.0
.IP \(bu 2
\fI\%1\ \ \ Manual\fP
.INDENT 2.0
.IP \(bu 2
\fI\%1.1\ \ \ Init\fP
.IP \(bu 2
\fI\%1.2\ \ \ Config\fP
.IP \(bu 2
\fI\%1.3\ \ \ Edit\fP
.INDENT 2.0
.IP \(bu 2
\fI\%1.3.1\ \ \ Edit entry\fP
.IP \(bu 2
\fI\%1.3.2\ \ \ Edit tag\fP
.UNINDENT
.UNINDENT
.UNINDENT
.SS 1.1\ \ \ Init
.SS 1.2\ \ \ Config
.sp
Config file lokks like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "fileName": "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b.pswd",
    "path": "/home/user/.tpassword\-store",
    "useGit": false,
    "pinentry": false,
    "clipboardClearTimeSec": 15,
    "storeMetaDataOnDisk": true,
    "showIcons": true
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 1.3\ \ \ Edit
.SS 1.3.1\ \ \ Edit entry
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "item/url*": "google.com",
    "title": "google",
    "username": "tpass@google.com",
    "password": "1234",
    "secret": "this is a test account",
    "tags": {
        "inUse": [],
        "chooseFrom": "All"
    }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 1.3.2\ \ \ Edit tag
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
{
    "title": "bitcoin",
    "icon": {
        "inUse": "social\-bitcoin",
        "chooseFrom:": "home, person\-stalker, social\-bitcoin, person, star, flag, heart, settings, email, cloud, alert\-circled, android\-cart, image, card, earth, wifi"
    }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH 1\ \ \ # DESIGN RATIONALE
.SS The tiny table of contents
.INDENT 0.0
.IP \(bu 2
\fI\%1\ \ \ # Design Rationale\fP
.INDENT 2.0
.IP \(bu 2
\fI\%1.1\ \ \ Introduction\fP
.IP \(bu 2
\fI\%1.2\ \ \ ## Privacy\fP
.IP \(bu 2
\fI\%1.3\ \ \ ## Cryptography\fP
.INDENT 2.0
.IP \(bu 2
\fI\%1.3.1\ \ \ ### Entropy\fP
.UNINDENT
.IP \(bu 2
\fI\%1.4\ \ \ ## Syncing\fP
.UNINDENT
.UNINDENT
.SS 1.1\ \ \ Introduction
.sp
Tpass is build with simplicity in mind. All should be 100% compatible with
Trezor Password Manager. It is build with unix philosophy in mind, every output
could be the input for another application, which means itâ€™s scriptable. The
application is cross plattform and runs on Linux,Windows and MacOS. All the
crypto implementation is handled by Trezor Device. The Input and CLI methods are
implemented with click.
.SS 1.2\ \ \ ## Privacy
.sp
There are two mods aviable for handling metadata
.SS 1.3\ \ \ ## Cryptography
.sp
Trezor has provided python implementations for the decryption functions of the
TPM. Tpass has implented the complement encryption function.
.SS 1.3.1\ \ \ ### Entropy
.sp
All the random data needed for generating the initialization vector iv is
taken from os.random() and the trezor device 50:50, with the following function:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def getEntropy(client, length):
    trezor_entropy = misc.get_entropy(client, length//2)
    urandom_entropy = os.urandom(length//2)
    entropy = trezor_entropy + urandom_entropy
    if len(entropy) != length:
        raise ValueError(str(length) + \(aq bytes entropy expected\(aq)
    return entropy
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Storage decryption function is taking from trezorlib/python/tools/pwd_ready.py
\-> decryptStorage, the shown encrytion function is implemented by tpass.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def encryptStorage(db_json, store_path, encKey, iv):
    cipherkey = bytes.fromhex(encKey)
    cipher = Cipher(algorithms.AES(cipherkey), modes.GCM(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    cipherText = encryptor.update(json.dumps(db_json).encode("UTF\-8", "replace")) + encryptor.finalize()
    cipherText = iv + encryptor.tag + cipherText
    with open(store_path, \(aqwb\(aq) as f:
        f.write(cipherText)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Similar entry decryption function is taking from trezorlib/python/tools/
pwd_ready.py \-> decryptEntryValue, the shown encrytion function is implemented
by tpass.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def encryptEntryValue(nonce, val, iv):
    cipherkey = bytes.fromhex(nonce)
    cipher = Cipher(algorithms.AES(cipherkey), modes.GCM(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    cipherText = encryptor.update(val.encode("utf\-8", "replace")) + encryptor.finalize()
    cipherText = iv + encryptor.tag + cipherText
    return [x for x in cipherText]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS 1.4\ \ \ ## Syncing
.sp
There are three cloud options aviable and offline mode. When the password file
is read on startup, by the \fIunlock_storage\fP method, than a lockfile is created
~/.tpass/tpass.lock and is deleted on normal exit or when a exception occurs.
If a second instance of tpass is trying to read the password file, it discovers
the lockfile and exits. When saving changes to the password file, it is also
checked by timestamp, if it changed in the meantime and only proceeds on an
unchanged pwd file.
.SH CONTRIBUTE
.SS depencies
.SS pull from git
.sp
clone repository
.sp
update
.SS unittests
.sp
depencies
.sp
download emulator
.sp
update
.SS upload to pypi
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
modindex
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
makk4
.SH COPYRIGHT
2019, makk4
.\" Generated by docutils manpage writer.
.
